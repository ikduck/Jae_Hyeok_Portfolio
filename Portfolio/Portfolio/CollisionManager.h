#pragma once // 헤더끼리 겹쳐서 문제가 발생하는 것을 방지해줌
#include "Headers.h"
#include "Object.h"
#include "MathManager.h"
class CollisionManager
{
public:
	static bool RectCollision( const Object* _ObjA , const Object* _ObjB)
	{
		// ** Position 받아옴
		Vector3 Position_A = _ObjA->GetPosition();
		Vector3 Position_B = _ObjB->GetPosition();

		// ** Sclae 받아옴
		Vector3 Scale_A = _ObjA->GetScale();
		Vector3 Scale_B = _ObjB->GetScale();

		// 탑뷰
		// ** 충돌이 되었다면  (높이가 같을때)
		/*
		if (Position_A.x + Scale_A.x > Position_B.x &&
			Position_B.x + Scale_B.x > Position_A.x &&
			Position_A.y == Position_B.y)
			return true;

		// ** 아니라면 
		return false;
		*/
		
		// 메이플 (사이드뷰)
		
		if (Position_A.x + (Scale_A.x  *  0.5f) > Position_B.x - (Scale_B.x * 0.5f) &&
			Position_B.x + (Scale_B.x  *  0.5f) > Position_A.x - (Scale_A.x * 0.5f) &&
			Position_A.y + (Scale_A.y * 0.5f) > Position_B.y - (Scale_B.y * 0.5f) &&
			Position_B.y + (Scale_B.y * 0.5f) > Position_A.y - (Scale_A.y * 0.5f))
			return true;
			
		// 던파 (횡스크롤)
		/*
			if ((Position_A.x + (Scale_A.x * 0.5f)) > (Position_B.x - (Scale_B.x * 0.5f)) &&
			(Position_B.x + (Scale_B.x * 0.5f)) > (Position_A.x - (Scale_A.x * 0.5f)) &&
			(Position_A.y + (Scale_A.y * 0.5f)) == (Position_B.y + (Scale_B.y * 0.5f)) )
			return true;
		*/
		return false;
	}
	static bool CircleCollision(const Object* _ObjA, const Object* _ObjB)
	{
		float Distance = MathManager::GetDistance(_ObjA->GetPosition(), _ObjB->GetPosition());

		float sum = _ObjA->GetScale().x * 0.5f + _ObjB->GetScale().x * 0.5f;

		if (Distance < sum)
			return true;
		
		return false;
	}
};

